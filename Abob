from .. import loader, utils
from asyncio import sleep
from datetime import datetime
from typing import Optional

@loader.tds
class CityAutomation(loader.Module):
    """–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –≥–æ—Ä–æ–¥–∞ –¥–ª—è @good_biznesbot | by @TaKaYaMa4a"""

    strings = {
        "name": "CityAutomation",
        "author": "@adamantinesss",
        "started": "üöÄ –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –∑–∞–ø—É—â–µ–Ω–∞",
        "stopped": "üõë –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞",
        "stats": "üìä –¶–∏–∫–ª #{}\n‚è± –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: {}",
        "error": "‚ö†Ô∏è –û—à–∏–±–∫–∞: {}",
        "interval_info": "‚è∞ –ò–Ω—Ç–µ—Ä–≤–∞–ª: {} –º–∏–Ω"
    }

    def __init__(self):
        self.start_time = None
        self.cycles = 0
        self.active = False
        self.config = loader.ModuleConfig(
            "WORK_INTERVAL", 60,
            lambda: "–ò–Ω—Ç–µ—Ä–≤–∞–ª –º–µ–∂–¥—É —Ü–∏–∫–ª–∞–º–∏ (–≤ –º–∏–Ω—É—Ç–∞—Ö)"
        )

    async def client_ready(self, client, db):
        self.client = client
        self._db = db

    async def _click_button(self, msg, button_text: str) -> bool:
        """–ù–∞–∂–∏–º–∞–µ—Ç –∫–Ω–æ–ø–∫—É –∏ –∂–¥—ë—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è"""
        if not hasattr(msg, 'buttons') or not msg.buttons:
            return False

        for row in msg.buttons:
            for button in row:
                if button_text in button.text:
                    old_text = msg.text
                    await button.click()
                    await sleep(2)  # –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –ö–î 2 —Å–µ–∫—É–Ω–¥—ã
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏–∑–º–µ–Ω–∏–ª–æ—Å—å –ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ
                    try:
                        new_msg = await self.client.get_messages(msg.peer_id, ids=msg.id)
                        return new_msg.text != old_text
                    except:
                        return False
        return False

    async def citystartcmd(self, message):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—é | .citystart"""
        if self.active:
            await utils.answer(message, "‚ùó –£–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç!")
            return

        self.active = True
        self.start_time = datetime.now()
        self.cycles = 0

        await utils.answer(message, 
            f"{self.strings['started']}\n"
            f"{self.strings['interval_info'].format(self.config['WORK_INTERVAL'])}"
        )

        while self.active:
            try:
                # 1. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º /city
                await self.client.send_message("@good_biznesbot", "/city")
                await sleep(2)  # –ñ–¥—ë–º –æ—Ç–≤–µ—Ç–∞

                # 2. –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                msgs = await self.client.get_messages("@good_biznesbot", limit=1)
                if not msgs:
                    await sleep(5)
                    continue

                msg = msgs[0]
                
                # 3. –ù–∞–∂–∏–º–∞–µ–º –∫–Ω–æ–ø–∫–∏ –ø–æ –æ—á–µ—Ä–µ–¥–∏
                buttons_to_click = ["–ú–µ–≥–∞–ø–æ–ª–∏—Å", "–†–µ—Å—É—Ä—Å–Ω—ã–µ —Ç–æ—á–∫–∏", "–£–ª—É—á—à–∏—Ç—å –≤—Å–µ"]
                for button_text in buttons_to_click:
                    if not self.active:
                        break
                    await self._click_button(msg, button_text)
                    msg = await self.client.get_messages("@good_biznesbot", limit=1)  # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
                    msg = msg[0] if msg else None
                    if not msg:
                        break

                # 4. –û—Ç—á—ë—Ç –∏ –æ–∂–∏–¥–∞–Ω–∏–µ
                self.cycles += 1
                uptime = str(datetime.now() - self.start_time).split('.')[0]
                await utils.answer(
                    message,
                    f"{self.strings['stats'].format(self.cycles, uptime)}\n"
                    f"üîÑ –°–ª–µ–¥—É—é—â–∏–π —Ü–∏–∫–ª —á–µ—Ä–µ–∑ {self.config['WORK_INTERVAL']} –º–∏–Ω"
                )
                await sleep(self.config['WORK_INTERVAL'] * 60)

            except Exception as e:
                await utils.answer(message, self.strings['error'].format(str(e)))
                await sleep(10)

    async def citystopcmd(self, message):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å | .citystop"""
        if not self.active:
            await utils.answer(message, "‚ùó –ù–µ –∑–∞–ø—É—â–µ–Ω–∞!")
            return

        self.active = False
        uptime = str(datetime.now() - self.start_time).split('.')[0]
        await utils.answer(
            message,
            f"{self.strings['stopped']}\n"
            f"‚è± –û–±—â–µ–µ –≤—Ä–µ–º—è: {uptime}\n"
            f"üîÅ –í—Å–µ–≥–æ —Ü–∏–∫–ª–æ–≤: {self.cycles}"
        )

    async def cityconfigcmd(self, message):
        """–ò–∑–º–µ–Ω–∏—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª | .cityconfig <–º–∏–Ω—É—Ç—ã>"""
        args = utils.get_args(message)
        if not args or not args[0].isdigit():
            await utils.answer(
                message,
                f"{self.strings['interval_info'].format(self.config['WORK_INTERVAL'])}\n"
                "‚ùï –ü—Ä–∏–º–µ—Ä: .cityconfig 30"
            )
            return

        new_interval = int(args[0])
        if new_interval < 1:
            await utils.answer(message, "‚ùå –ò–Ω—Ç–µ—Ä–≤–∞–ª –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å > 0!")
            return

        self.config['WORK_INTERVAL'] = new_interval
        await utils.answer(message, f"‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: {new_interval} –º–∏–Ω")
